// ============================================
// BULLETPROOF THOUSAND SEPARATOR SOLUTION
// Fixed for consistency and dynamic elements
// ============================================

(function() {
    'use strict';

    // Format number with thousand separator
    function formatNumber(value) {
        if (value === '' || value === null || value === undefined) return '';
        
        // Remove all non-numeric characters except decimal point and minus
        let num = value.toString().replace(/[^\d.-]/g, '');
        
        // Handle empty or invalid input
        if (num === '' || num === '-') return num;
        
        // Parse the number
        let floatNum = parseFloat(num);
        if (isNaN(floatNum)) return '';
        
        // Split into integer and decimal parts
        let parts = num.split('.');
        let integerPart = parts[0];
        let decimalPart = parts[1];
        
        // Add thousand separators to integer part
        integerPart = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        
        // Reconstruct the number
        return decimalPart !== undefined ? integerPart + '.' + decimalPart : integerPart;
    }

    // Remove formatting to get raw number
    function unformatNumber(value) {
        if (value === '' || value === null || value === undefined) return '';
        return value.toString().replace(/,/g, '');
    }

    // Parse to float for calculations
    function parseNumber(value) {
        if (value === '' || value === null || value === undefined) return 0;
        let cleaned = unformatNumber(value);
        return cleaned === '' ? 0 : parseFloat(cleaned) || 0;
    }

    // Track initialized inputs
    const initializedInputs = new WeakSet();

    // Apply formatting to a single input
    function formatInput(input) {
        // Skip if already initialized
        if (initializedInputs.has(input)) return;
        initializedInputs.add(input);

        // Change type to text to allow formatting display
        const originalType = input.type;
        if (input.type === 'number') {
            input.type = 'text';
            input.setAttribute('inputmode', 'decimal');
        }

        // Store raw value
        input._rawValue = unformatNumber(input.value || '');
        
        // Real-time formatting while typing
        input.addEventListener('input', function(e) {
            let cursorPos = this.selectionStart;
            let oldValue = this.value;
            let oldLength = oldValue.length;
            
            // Get raw value
            let rawValue = unformatNumber(oldValue);
            this._rawValue = rawValue;
            
            // Format and display
            let formattedValue = formatNumber(rawValue);
            this.value = formattedValue;
            
            // Adjust cursor position
            let newLength = formattedValue.length;
            let diff = newLength - oldLength;
            this.setSelectionRange(cursorPos + diff, cursorPos + diff);
        });

        // Format on blur
        input.addEventListener('blur', function() {
            let rawValue = this._rawValue || unformatNumber(this.value);
            if (rawValue !== '' && rawValue !== undefined) {
                this.value = formatNumber(rawValue);
            }
        });

        // Override value property getter
        Object.defineProperty(input, 'valueAsNumber', {
            get: function() {
                return parseNumber(this._rawValue || this.value);
            },
            configurable: true
        });

        // Display formatted initial value
        if (input._rawValue) {
            input.value = formatNumber(input._rawValue);
        }
    }

    // Apply formatting to all matching inputs
    function applyFormatting() {
        // More comprehensive selector
        const selectors = [
            'input[type="number"]',
            'input[type="text"][name*="price"]',
            'input[type="text"][name*="amount"]',
            'input[type="text"][name*="rate"]',
            'input[type="text"][name*="cost"]',
            'input[type="text"][name*="total"]',
            'input[type="text"][name*="quantity"]',
            'input[type="text"][name*="qty"]',
            'input.number-input',
            'input[data-format="number"]',
            'input[data-type="number"]'
        ];

        try {
            const numberInputs = document.querySelectorAll(selectors.join(', '));
            
            numberInputs.forEach(function(input) {
                try {
                    formatInput(input);
                } catch (err) {
                    console.warn('Error formatting input:', input, err);
                }
            });
        } catch (err) {
            console.error('Error in applyFormatting:', err);
        }
    }

    // Intercept common calculation methods
    const originalParseFloat = window.parseFloat;
    const originalParseInt = window.parseInt;

    window.parseFloat = function(value) {
        if (typeof value === 'string') {
            value = unformatNumber(value);
        }
        return originalParseFloat.call(this, value);
    };

    window.parseInt = function(value, radix) {
        if (typeof value === 'string') {
            value = unformatNumber(value);
        }
        return originalParseInt.call(this, value, radix);
    };

    // Initialize on DOM ready
    function init() {
        applyFormatting();
        
        // Re-scan periodically for dynamic content (aggressive approach)
        setInterval(function() {
            applyFormatting();
        }, 1000);
        
        // Also watch for DOM changes
        if (window.MutationObserver) {
            const observer = new MutationObserver(function(mutations) {
                let shouldReapply = false;
                
                for (let i = 0; i < mutations.length; i++) {
                    const mutation = mutations[i];
                    
                    if (mutation.addedNodes.length > 0) {
                        for (let j = 0; j < mutation.addedNodes.length; j++) {
                            const node = mutation.addedNodes[j];
                            
                            if (node.nodeType === 1) { // Element node
                                if (node.tagName === 'INPUT' || 
                                    (node.querySelector && node.querySelector('input'))) {
                                    shouldReapply = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (shouldReapply) break;
                }
                
                if (shouldReapply) {
                    setTimeout(applyFormatting, 100);
                }
            });

            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Expose utility functions globally
    window.NumberFormatter = {
        format: formatNumber,
        unformat: unformatNumber,
        parse: parseNumber,
        
        // Get raw value
        getRawValue: function(inputElement) {
            return inputElement._rawValue || unformatNumber(inputElement.value);
        },
        
        // Manually apply to specific input
        applyTo: function(input) {
            formatInput(input);
        },
        
        // Manually scan for new inputs
        refresh: function() {
            applyFormatting();
        }
    };

})();

// ============================================
// FORM SUBMISSION HANDLER
// ============================================

(function() {
    // Store original submit
    const originalSubmit = HTMLFormElement.prototype.submit;
    
    function handleSubmit(form) {
        const numberInputs = form.querySelectorAll('input[type="text"]');
        const hiddenInputs = [];
        
        numberInputs.forEach(function(input) {
            if (input._rawValue !== undefined || input.value.includes(',')) {
                const rawValue = input._rawValue || NumberFormatter.unformat(input.value);
                
                // Create hidden input with raw value
                const hiddenInput = document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = input.name;
                hiddenInput.value = rawValue;
                hiddenInput.className = '_temp_raw_value';
                
                // Store reference
                hiddenInputs.push({ hidden: hiddenInput, original: input });
                
                // Temporarily change name of formatted input
                input.dataset.originalName = input.name;
                input.name = input.name + '_formatted_temp';
                
                // Add hidden input
                form.appendChild(hiddenInput);
            }
        });
        
        return hiddenInputs;
    }
    
    function cleanupSubmit(hiddenInputs) {
        hiddenInputs.forEach(function(item) {
            // Restore original name
            if (item.original.dataset.originalName) {
                item.original.name = item.original.dataset.originalName;
                delete item.original.dataset.originalName;
            }
            
            // Remove hidden input
            if (item.hidden.parentNode) {
                item.hidden.parentNode.removeChild(item.hidden);
            }
        });
    }
    
    // Override form.submit()
    HTMLFormElement.prototype.submit = function() {
        const hiddenInputs = handleSubmit(this);
        originalSubmit.call(this);
        setTimeout(function() {
            cleanupSubmit(hiddenInputs);
        }, 100);
    };
    
    // Handle form submit event
    document.addEventListener('submit', function(e) {
        const form = e.target;
        const hiddenInputs = handleSubmit(form);
        
        setTimeout(function() {
            cleanupSubmit(hiddenInputs);
        }, 100);
    }, true);
})();


For Extra Safety on Edit Pages:
If you want to ensure all values are formatted immediately, add this at the bottom of your edit page:
javascript<script>
// Run after page fully loads
window.addEventListener('load', function() {
    NumberFormatter.refresh();
});
</script>
