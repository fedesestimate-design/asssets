(function() {
    'use strict';

    // Format number with thousand separator
    function formatNumber(value) {
        if (value === '' || value === null || value === undefined) return '';
        
        // Remove all non-numeric characters except decimal point and minus
        let num = value.toString().replace(/[^\d.-]/g, '');
        
        // Handle empty or invalid input
        if (num === '' || num === '-') return num;
        
        // Parse the number
        let floatNum = parseFloat(num);
        if (isNaN(floatNum)) return '';
        
        // Split into integer and decimal parts
        let parts = num.split('.');
        let integerPart = parts[0];
        let decimalPart = parts[1];
        
        // Add thousand separators to integer part
        integerPart = integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        
        // Reconstruct the number
        return decimalPart !== undefined ? integerPart + '.' + decimalPart : integerPart;
    }

    // Remove formatting to get raw number
    function unformatNumber(value) {
        if (value === '' || value === null || value === undefined) return '';
        return value.toString().replace(/,/g, '');
    }

    // Parse to float for calculations
    function parseNumber(value) {
        if (value === '' || value === null || value === undefined) return 0;
        let cleaned = unformatNumber(value);
        return cleaned === '' ? 0 : parseFloat(cleaned) || 0;
    }

    // Track initialized inputs
    const initializedInputs = new WeakSet();

    // Apply formatting to a single input
    function formatInput(input) {
        // Skip if already initialized
        if (initializedInputs.has(input)) return;
        initializedInputs.add(input);

        // Change type to text to allow formatting display
        const originalType = input.type;
        if (input.type === 'number') {
            input.type = 'text';
            input.setAttribute('inputmode', 'decimal');
        }

        // Store raw value
        input._rawValue = unformatNumber(input.value || '');
        
        // Real-time formatting while typing
        input.addEventListener('input', function(e) {
            let cursorPos = this.selectionStart;
            let oldValue = this.value;
            let oldLength = oldValue.length;
            
            // Get raw value
            let rawValue = unformatNumber(oldValue);
            this._rawValue = rawValue;
            
            // Format and display
            let formattedValue = formatNumber(rawValue);
            this.value = formattedValue;
            
            // Adjust cursor position
            let newLength = formattedValue.length;
            let diff = newLength - oldLength;
            this.setSelectionRange(cursorPos + diff, cursorPos + diff);
        });

        // Intercept value setter to auto-format calculated results
        const originalDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');
       Object.defineProperty(input, 'value', {
            get: function() {
                return originalDescriptor.get.call(this);
            },
            set: function(val) {

                // ðŸ›‘ prevent formatting during submission cleanup
                if (window.__NF_DISABLE === true) {
                    originalDescriptor.set.call(this, val);
                    return;
                }

                this._rawValue = unformatNumber(val);
                originalDescriptor.set.call(this, formatNumber(val));
            },
            configurable: true
        });

        // Format on blur
        input.addEventListener('blur', function() {
            let rawValue = this._rawValue || unformatNumber(this.value);
            if (rawValue !== '' && rawValue !== undefined) {
                this.value = formatNumber(rawValue);
            }
        });

        // Override value property getter
        Object.defineProperty(input, 'valueAsNumber', {
            get: function() {
                return parseNumber(this._rawValue || this.value);
            },
            configurable: true
        });

        // Display formatted initial value
        if (input._rawValue) {
            input.value = formatNumber(input._rawValue);
        }
    }

    // Apply formatting to all matching inputs
    function applyFormatting() {
        // More comprehensive selector
        const selectors = [
            'input[type="number"]',
            'input[type="text"][name*="price"]',
            'input[type="text"][name*="amount"]',
            'input[type="text"][name*="rate"]',
            'input[type="text"][name*="cost"]',
            'input[type="text"][name*="total"]',
            'input[type="text"][name*="quantity"]',
            'input[type="text"][name*="qty"]',
            'input.number-input',
            'input[data-format="number"]',
            'input[data-type="number"]'
        ];

        try {
            const numberInputs = document.querySelectorAll(selectors.join(', '));
            
            numberInputs.forEach(function(input) {
                try {
                    formatInput(input);
                } catch (err) {
                    console.warn('Error formatting input:', input, err);
                }
            });
        } catch (err) {
            console.error('Error in applyFormatting:', err);
        }
    }

    // Intercept common calculation methods
    const originalParseFloat = window.parseFloat;
    const originalParseInt = window.parseInt;

    window.parseFloat = function(value) {
        if (typeof value === 'string') {
            value = unformatNumber(value);
        }
        return originalParseFloat.call(this, value);
    };

    window.parseInt = function(value, radix) {
        if (typeof value === 'string') {
            value = unformatNumber(value);
        }
        return originalParseInt.call(this, value, radix);
    };

    // Initialize on DOM ready
    function init() {
        applyFormatting();
        
        // Re-scan periodically for dynamic content (aggressive approach)
        setInterval(function() {
            applyFormatting();
        }, 1000);
        
        // Also watch for DOM changes
        if (window.MutationObserver) {
            const observer = new MutationObserver(function(mutations) {
                let shouldReapply = false;
                
                for (let i = 0; i < mutations.length; i++) {
                    const mutation = mutations[i];
                    
                    if (mutation.addedNodes.length > 0) {
                        for (let j = 0; j < mutation.addedNodes.length; j++) {
                            const node = mutation.addedNodes[j];
                            
                            if (node.nodeType === 1) { // Element node
                                if (node.tagName === 'INPUT' || 
                                    (node.querySelector && node.querySelector('input'))) {
                                    shouldReapply = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (shouldReapply) break;
                }
                
                if (shouldReapply) {
                    setTimeout(applyFormatting, 100);
                }
            });

            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Expose utility functions globally
    window.NumberFormatter = {
        format: formatNumber,
        unformat: unformatNumber,
        parse: parseNumber,
        
        // Get raw value
        getRawValue: function(inputElement) {
            return inputElement._rawValue || unformatNumber(inputElement.value);
        },
        
        // Manually apply to specific input
        applyTo: function(input) {
            formatInput(input);
        },
        
        // Manually scan for new inputs
        refresh: function() {
            applyFormatting();
        }
    };

})();

// ============================================
// FORM SUBMISSION HANDLER - STRENGTHENED
// ============================================

(function() {
    function cleanFormValues(form) {
        const inputs = form.querySelectorAll('input[type="text"], input[type="hidden"]');
        const cleanedInputs = [];
        
        inputs.forEach(function(input) {
            // Skip already processed hidden inputs
            if (input.classList.contains('_temp_raw_value')) return;
            
            const value = input.value;
            
            // Check if value contains comma (formatted number)
            if (value && value.includes(',')) {
                const rawValue = unformatNumber(value);
                
                // Update the input value directly to raw number
                input.value = rawValue;
                
                // Store for potential restore
                cleanedInputs.push({
                    input: input,
                    originalValue: value
                });
            } else if (input._rawValue !== undefined) {
                // Use stored raw value
                input.value = input._rawValue;
                
                cleanedInputs.push({
                    input: input,
                    originalValue: value
                });
            }
        });
        
        return cleanedInputs;
    }
    
    function restoreFormValues(cleanedInputs) {
        cleanedInputs.forEach(function(item) {
            item.input.value = item.originalValue;
        });
    }
    
    // Handle form submit event (BEFORE submission)
    document.addEventListener('submit', function (e) {
        const form = e.target;

        window.__NF_DISABLE = true; // turn OFF formatting

        const cleanedInputs = form.querySelectorAll('input');

        cleanedInputs.forEach(inp => {
            inp.value = inp._rawValue ? inp._rawValue : unformatNumber(inp.value);
        });

        window.__NF_DISABLE = false; // re-enable formatting
    }, true);

 

    
    // Store original submit method
    const originalSubmit = HTMLFormElement.prototype.submit;
    
    // Override form.submit() for programmatic submissions
    HTMLFormElement.prototype.submit = function() {
        const cleanedInputs = cleanFormValues(this);
        
        // Call original submit
        originalSubmit.call(this);
        
        // Restore after submission
        setTimeout(function() {
            restoreFormValues(cleanedInputs);
        }, 500);
    };
    
    // Helper function exposed globally
    function unformatNumber(value) {
        if (value === '' || value === null || value === undefined) return '';
        return value.toString().replace(/,/g, '');
    }
})();